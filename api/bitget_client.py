# backend/api/bitget_client.py
import requests
import hmac
import hashlib
import base64
import time
import json
from urllib.parse import urlencode

class BitgetAPI:
    """Cliente para interagir com a API da Bitget"""
    
    def __init__(self, api_key, secret_key, passphrase=None):
        self.api_key = api_key
        self.secret_key = secret_key
        self.passphrase = passphrase
        self.base_url = "https://api.bitget.com"
        
    def _generate_signature(self, timestamp, method, request_path, body=""):
        """Gera assinatura para autentica√ß√£o na API Bitget"""
        # Split path and query string if present
        if '?' in request_path:
            path_parts = request_path.split('?', 1)
            path = path_parts[0]
            query_string = path_parts[1]
            # According to Bitget docs: timestamp + method + requestPath + "?" + queryString + body
            message = timestamp + method.upper() + path + '?' + query_string + body
        else:
            # No query string: timestamp + method + requestPath + body
            message = timestamp + method.upper() + request_path + body
            
        signature = base64.b64encode(
            hmac.new(
                self.secret_key.encode('utf-8'),
                message.encode('utf-8'),
                hashlib.sha256
            ).digest()
        ).decode('utf-8')
        return signature
    
    def _get_headers(self, timestamp, method, request_path, body=""):
        """Gera headers para requisi√ß√µes autenticadas"""
        signature = self._generate_signature(timestamp, method, request_path, body)
        headers = {
            'ACCESS-KEY': self.api_key,
            'ACCESS-SIGN': signature,
            'ACCESS-TIMESTAMP': timestamp,
            'Content-Type': 'application/json'
        }
        if self.passphrase:
            headers['ACCESS-PASSPHRASE'] = self.passphrase
        return headers
    
    def _send_request(self, method, endpoint, params=None, data=None):
        """
        Envia requisi√ß√£o para a API da Bitget
        """
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir query string se houver par√¢metros
            query_string = ''
            if params:
                # Remover par√¢metros None ou vazios
                params = {k: v for k, v in params.items() if v is not None}
                if params:
                    query_string = '?' + urlencode(params)
            
            request_path = endpoint + query_string
            
            # Preparar body se houver dados
            body = ''
            if data:
                body = json.dumps(data)
            
            # Gerar headers
            headers = self._get_headers(timestamp, method, request_path, body)
            
            # Fazer requisi√ß√£o
            url = self.base_url + request_path
            print(f"[BitgetAPI] Enviando requisi√ß√£o {method} para {url}")
            
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                data=body,
                timeout=30
            )
            
            print(f"[BitgetAPI] Status da resposta: {response.status_code}")
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"[BitgetAPI] Resposta: {json.dumps(response_data, indent=2)}")
                return response_data
            else:
                print(f"[BitgetAPI] Erro na requisi√ß√£o: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o ao enviar requisi√ß√£o: {e}")
            return None
    
    def validate_credentials(self):
        """Valida as credenciais da API fazendo uma chamada de teste com diagn√≥stico detalhado"""
        try:
            print(f"üîç Validando credenciais da API Bitget...")
            
            # Verifica√ß√µes b√°sicas das credenciais
            if not self.api_key or not self.secret_key:
                print(f"‚ùå Credenciais incompletas: API Key: {bool(self.api_key)}, Secret: {bool(self.secret_key)}, Passphrase: {bool(self.passphrase)}")
                return False
                
            # Verificar formato b√°sico das credenciais
            if not self.api_key.startswith('bg_'):
                print(f"‚ö†Ô∏è API Key n√£o parece ter formato Bitget v√°lido (deve come√ßar com 'bg_'): {self.api_key[:10]}...")
                
            print(f"üìä Testando credenciais com API Key: {self.api_key[:10]}...")
            
            # Tenta obter informa√ß√µes da conta para validar as credenciais
            timestamp = str(int(time.time() * 1000))
            request_path = "/api/spot/v1/account/assets"
            method = "GET"
            
            print(f"üåê Fazendo requisi√ß√£o para: {self.base_url + request_path}")
            headers = self._get_headers(timestamp, method, request_path)
            print(f"üìã Headers preparados (sem mostrar assinatura)")
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=10
            )
            
            print(f"üì° Status da resposta: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Resposta recebida: {json.dumps(data, indent=2)}")
                
                # Verifica se a resposta cont√©m dados v√°lidos
                is_valid = data.get('code') == '00000' or 'data' in data
                if is_valid:
                    print("‚úÖ Credenciais da API Bitget v√°lidas.")
                else:
                    print(f"‚ùå Credenciais inv√°lidas - c√≥digo de resposta: {data.get('code')}")
                return is_valid
            else:
                response_text = response.text
                print(f"‚ùå Erro na valida√ß√£o: {response.status_code} - {response_text}")
                
                # An√°lise espec√≠fica de erros comuns
                try:
                    error_data = response.json()
                    error_code = error_data.get('code')
                    error_msg = error_data.get('msg', '')
                    
                    if error_code == '40037':
                        print("üîë DIAGN√ìSTICO: API Key n√£o existe ou est√° incorreta")
                        print("üí° SOLU√á√ÉO: Verifique se copiou a API Key corretamente da Bitget")
                    elif error_code == '40038':
                        print("üîê DIAGN√ìSTICO: Secret Key est√° incorreto")
                        print("üí° SOLU√á√ÉO: Verifique se copiou o Secret Key corretamente")
                    elif error_code == '40710':
                        print("üö´ DIAGN√ìSTICO: Status da conta anormal")
                        print("üí° SOLU√á√ÉO: Sua conta Bitget pode estar bloqueada ou com restri√ß√µes")
                    elif error_code == '40103':
                        print("üîí DIAGN√ìSTICO: Passphrase incorreta")
                        print("üí° SOLU√á√ÉO: Verifique se o passphrase est√° correto")
                    elif error_code == '40104':
                        print("üïê DIAGN√ìSTICO: Timestamp da requisi√ß√£o inv√°lido")
                        print("üí° SOLU√á√ÉO: Problema de sincroniza√ß√£o de hor√°rio")
                    elif error_code == '40105':
                        print("üîè DIAGN√ìSTICO: Assinatura inv√°lida")
                        print("üí° SOLU√á√ÉO: Problema na gera√ß√£o da assinatura - verifique todas as credenciais")
                    elif 'permission' in error_msg.lower():
                        print("üõ°Ô∏è DIAGN√ìSTICO: Permiss√µes insuficientes")
                        print("üí° SOLU√á√ÉO: A API Key precisa de permiss√µes de 'Read' no m√≠nimo")
                        print("üîß CONFIGURAR: Acesse Bitget > API Management > Edit API > Enable 'Read' permissions")
                    else:
                        print(f"‚ùì DIAGN√ìSTICO: Erro n√£o identificado - C√≥digo: {error_code}, Mensagem: {error_msg}")
                        
                except Exception as json_error:
                    print(f"‚ùå Erro ao processar resposta JSON: {json_error}")
                    
                return False
                
        except requests.exceptions.Timeout:
            print("‚è∞ DIAGN√ìSTICO: Timeout na conex√£o com a API Bitget")
            print("üí° SOLU√á√ÉO: Verifique sua conex√£o com a internet")
            return False
        except requests.exceptions.ConnectionError:
            print("üåê DIAGN√ìSTICO: Erro de conex√£o com a API Bitget")
            print("üí° SOLU√á√ÉO: Verifique sua conex√£o com a internet ou se a API da Bitget est√° funcionando")
            return False
        except Exception as e:
            print(f"‚ùå Erro inesperado ao validar credenciais: {e}")
            return False
    
    def get_account_balance(self):
        """Obt√©m o saldo da conta"""
        try:
            timestamp = str(int(time.time() * 1000))
            request_path = "/api/spot/v1/account/assets"
            method = "GET"
            
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                return None
                
        except Exception as e:
            print(f"Erro ao obter saldo: {e}")
            return None
    
    def get_futures_positions(self, product_type="USDT-FUTURES", margin_coin=None):
        """Obt√©m posi√ß√µes de futuros usando API v2"""
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {'productType': product_type}
            if margin_coin:
                params['marginCoin'] = margin_coin
            
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/position/all-position?{query_string}"
            method = "GET"
            
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"HTTP Error {response.status_code}: {response.text}")
                return None
                
        except Exception as e:
            print(f"Erro ao obter posi√ß√µes: {e}")
            return None
    
    def get_order_history(self, product_type="USDT-FUTURES", symbol=None, limit=100, start_time=None, end_time=None, cursor=None):
        """Obt√©m hist√≥rico de ordens usando API v2"""
        try:
            timestamp = str(int(time.time() * 1000))
            params = {
                'productType': product_type,
                'limit': str(limit)
            }
            if symbol:
                params['symbol'] = symbol
            if start_time:
                params['startTime'] = str(start_time)
            if end_time:
                params['endTime'] = str(end_time)
            if cursor: # Adicionado para suportar pagina√ß√£o, se aplic√°vel
                params['cursor'] = cursor
                
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/order/orders-history?{query_string}"
            method = "GET"
            
            print(f"[BitgetAPI] Chamando get_order_history com path: {request_path}") # Log dos par√¢metros
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=15 # Aumentado timeout para hist√≥rico
            )
            
            response_data = response.json()
            print(f"[BitgetAPI] Resposta de get_order_history (status {response.status_code}): {json.dumps(response_data, indent=2)}") # Log da resposta crua

            if response.status_code == 200:
                return response_data
            else:
                print(f"[BitgetAPI] Erro HTTP em get_order_history: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o em get_order_history: {e}")
            return None
    
    def get_history_orders(self, **kwargs):
        """
        Busca o hist√≥rico de ordens fechadas
        """
        endpoint = '/api/mix/v1/order/history'
        params = {
            'symbol': kwargs.get('symbol'),
            'startTime': kwargs.get('start_time'),
            'endTime': kwargs.get('end_time'),
            'limit': kwargs.get('limit', 100)
        }
        return self._send_request('GET', endpoint, params)
    
    def get_closed_positions_history(self, product_type="USDT-FUTURES", symbol=None, limit=100, start_time=None, end_time=None):
        """
        Busca o hist√≥rico de posi√ß√µes fechadas usando a API v2
        """
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {
                'productType': product_type,
                'pageSize': str(limit)
            }
            
            if symbol:
                params['symbol'] = symbol
            if start_time:
                params['startTime'] = str(start_time)
            if end_time:
                params['endTime'] = str(end_time)
                
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/position/history-position?{query_string}"
            method = "GET"
            
            print(f"[BitgetAPI] Chamando get_closed_positions_history com path: {request_path}")
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=15
            )
            
            response_data = response.json()
            print(f"[BitgetAPI] Resposta de get_closed_positions_history (status {response.status_code}): {json.dumps(response_data, indent=2)}")

            if response.status_code == 200:
                return response_data
            else:
                print(f"[BitgetAPI] Erro HTTP em get_closed_positions_history: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o em get_closed_positions_history: {e}")
            return None
    
    def get_orders_history(self, product_type="USDT-FUTURES", symbol=None, limit=100, start_time=None, end_time=None):
        """
        Busca o hist√≥rico de ordens usando a API v2 (inclui campo leverage)
        """
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {
                'productType': product_type,
                'limit': str(limit)
            }
            
            if symbol:
                params['symbol'] = symbol
            if start_time:
                params['startTime'] = str(start_time)
            if end_time:
                params['endTime'] = str(end_time)
                
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/order/orders-history?{query_string}"
            method = "GET"
            
            print(f"[BitgetAPI] Chamando get_orders_history com path: {request_path}")
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=15
            )
            
            response_data = response.json()
            print(f"[BitgetAPI] Resposta de get_orders_history (status {response.status_code}): {json.dumps(response_data, indent=2)}")

            if response.status_code == 200:
                return response_data
            else:
                print(f"[BitgetAPI] Erro HTTP em get_orders_history: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o em get_orders_history: {e}")
            return None

    def get_futures_balance(self, product_type="USDT-FUTURES", margin_coin="USDT"):
        """Obt√©m saldo da conta de futuros usando API v2"""
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {'productType': product_type}
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/account/accounts?{query_string}"
            method = "GET"
            
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"HTTP Error {response.status_code}: {response.text}")
                return None
                
        except Exception as e:
            print(f"Erro ao obter saldo de futuros: {e}")
            return None
    
    def get_all_positions(self, product_type="USDT-FUTURES", margin_coin=None):
        """Obt√©m todas as posi√ß√µes atuais usando endpoint all-position que fornece dados completos incluindo leverage"""
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {'productType': product_type}
            if margin_coin:
                params['marginCoin'] = margin_coin
                
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/position/all-position?{query_string}"
            method = "GET"
            
            print(f"[BitgetAPI] Chamando get_all_positions com path: {request_path}")
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=15
            )
            
            response_data = response.json()
            print(f"[BitgetAPI] Resposta de get_all_positions (status {response.status_code}): {json.dumps(response_data, indent=2)}")

            if response.status_code == 200:
                return response_data
            else:
                print(f"[BitgetAPI] Erro HTTP em get_all_positions: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o em get_all_positions: {e}")
            return None
    
    def get_margin_for_symbol(self, symbol, product_type="USDT-FUTURES"):
        """
        Busca dados de margem espec√≠ficos para um s√≠mbolo usando o endpoint all-position
        √ötil para obter dados de margem que n√£o est√£o dispon√≠veis no hist√≥rico
        """
        try:
            print(f"[BitgetAPI] Buscando margem para s√≠mbolo: {symbol}")
            
            # Buscar todas as posi√ß√µes atuais
            all_positions_response = self.get_all_positions(product_type=product_type)
            
            if not all_positions_response or all_positions_response.get('code') != '00000':
                print(f"[BitgetAPI] Erro ao buscar posi√ß√µes para margem: {all_positions_response}")
                return None
                
            positions = all_positions_response.get('data', [])
            
            # Procurar pela posi√ß√£o espec√≠fica do s√≠mbolo
            for position in positions:
                if position.get('symbol') == symbol:
                    margin_size = position.get('marginSize')
                    if margin_size and float(margin_size) > 0:
                        print(f"[BitgetAPI] Margem encontrada para {symbol}: {margin_size}")
                        return {
                            'symbol': symbol,
                            'marginSize': float(margin_size),
                            'marginCoin': position.get('marginCoin'),
                            'leverage': position.get('leverage'),
                            'holdSide': position.get('holdSide'),
                            'source': 'all-position'
                        }
                    else:
                        print(f"[BitgetAPI] Posi√ß√£o encontrada para {symbol}, mas sem margem ativa")
                        return None
            
            print(f"[BitgetAPI] Nenhuma posi√ß√£o ativa encontrada para {symbol}")
            return None
            
        except Exception as e:
            print(f"[BitgetAPI] Erro ao buscar margem para {symbol}: {e}")
            return None

    def get_position_history(self, product_type="USDT-FUTURES", symbol=None, limit=100, start_time=None, end_time=None):
        """Obt√©m hist√≥rico de posi√ß√µes fechadas usando endpoint espec√≠fico para posi√ß√µes"""
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {
                'productType': product_type,
                'pageSize': str(limit)
            }
            
            if symbol:
                params['symbol'] = symbol
            if start_time:
                params['startTime'] = str(start_time)
            if end_time:
                params['endTime'] = str(end_time)
                
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/position/history-position?{query_string}"
            method = "GET"
            
            print(f"[BitgetAPI] Chamando get_position_history com path: {request_path}")
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=15
            )
            
            response_data = response.json()
            print(f"[BitgetAPI] Resposta de get_position_history (status {response.status_code}): {json.dumps(response_data, indent=2)}")

            if response.status_code == 200:
                return response_data
            else:
                print(f"[BitgetAPI] Erro HTTP em get_position_history: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o em get_position_history: {e}")
            return None

    def flash_close_position(self, symbol, hold_side=None, product_type="USDT-FUTURES"):
        """Fecha posi√ß√£o usando flash close (market price)"""
        try:
            timestamp = str(int(time.time() * 1000))
            request_path = "/api/v2/mix/order/close-positions"
            method = "POST"
            
            # Corpo da requisi√ß√£o
            body_data = {
                "symbol": symbol,
                "productType": product_type
            }
            
            # Adicionar holdSide se especificado
            if hold_side:
                body_data["holdSide"] = hold_side
            
            body = json.dumps(body_data)
            
            headers = self._get_headers(timestamp, method, request_path, body)
            
            print(f"[BitgetAPI] Flash close position - Symbol: {symbol}, HoldSide: {hold_side}")
            
            response = requests.post(
                self.base_url + request_path,
                headers=headers,
                data=body,
                timeout=30
            )
            
            print(f"[BitgetAPI] Flash close response status: {response.status_code}")
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"[BitgetAPI] Flash close response: {json.dumps(response_data, indent=2)}")
                return response_data
            else:
                print(f"[BitgetAPI] Erro ao fechar posi√ß√£o: {response.status_code} - {response.text}")
                return {
                    'code': str(response.status_code),
                    'msg': response.text,
                    'success': False
                }
                
        except Exception as e:
            print(f"[BitgetAPI] Exce√ß√£o ao fechar posi√ß√£o: {e}")
            return {
                'code': '500',
                'msg': str(e),
                'success': False
            }
    
    def get_fills_history(self, product_type="USDT-FUTURES", symbol=None, limit=100, start_time=None, end_time=None):
        """Obt√©m hist√≥rico de execu√ß√µes (fills) para identificar trades fechados"""
        try:
            timestamp = str(int(time.time() * 1000))
            
            # Construir par√¢metros de query
            params = {
                'productType': product_type,
                'pageSize': str(limit)
            }
            
            if symbol:
                params['symbol'] = symbol
            if start_time:
                params['startTime'] = str(start_time)
            if end_time:
                params['endTime'] = str(end_time)
                
            query_string = urlencode(params)
            request_path = f"/api/v2/mix/order/fills?{query_string}"
            method = "GET"
            
            headers = self._get_headers(timestamp, method, request_path)
            
            response = requests.get(
                self.base_url + request_path,
                headers=headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"HTTP Error {response.status_code}: {response.text}")
                return None
                
        except Exception as e:
            print(f"Erro ao obter hist√≥rico de execu√ß√µes: {e}")
            return None
    
    def get_ticker(self, symbol):
        """Obt√©m informa√ß√µes do ticker (pre√ßo atual) de um s√≠mbolo"""
        try:
            # Primeiro tentar endpoint espec√≠fico com formato de futuros
            try:
                response = requests.get(
                    f"{self.base_url}/api/v2/mix/market/ticker?symbol={symbol}",
                    timeout=10
                )
                if response.status_code == 200:
                    data = response.json()
                    if data.get('code') == '00000':
                        return data
            except Exception:
                pass
            
            # Fallback: usar endpoint de todos os tickers e filtrar
            response = requests.get(
                f"{self.base_url}/api/v2/mix/market/tickers?productType=USDT-FUTURES",
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == '00000' and data.get('data'):
                    # Procurar o s√≠mbolo espec√≠fico
                    for ticker in data['data']:
                        if ticker.get('symbol') == symbol:
                            return {
                                'code': '00000',
                                'data': [ticker]
                            }
                    
                    # Se n√£o encontrar exato, tentar varia√ß√µes
                    for ticker in data['data']:
                        symbol_variants = [symbol, f"{symbol}_UMCBL", f"{symbol}PERP"]
                        if ticker.get('symbol') in symbol_variants:
                            return {
                                'code': '00000',
                                'data': [ticker]
                            }
                            
            print(f"S√≠mbolo {symbol} n√£o encontrado nos tickers")
            return None
                
        except Exception as e:
            print(f"Erro ao obter ticker para {symbol}: {e}")
            return None

    def get_usd_brl_rate(self):
        """Obt√©m a taxa de c√¢mbio USD/BRL usando APIs p√∫blicas confi√°veis"""
        try:
            # M√©todo 1: Tentar ExchangeRate API (gratuita e confi√°vel)
            try:
                response = requests.get(
                    "https://api.exchangerate-api.com/v4/latest/USD",
                    timeout=10
                )
                
                if response.status_code == 200:
                    data = response.json()
                    brl_rate = data.get('rates', {}).get('BRL')
                    if brl_rate and brl_rate > 0:
                        print(f"[BitgetAPI] Taxa USD/BRL obtida da ExchangeRate API: {brl_rate:.4f}")
                        return float(brl_rate)
            except Exception as e:
                print(f"[BitgetAPI] Erro na ExchangeRate API: {e}")
            
            # M√©todo 2: Tentar API do Banco Central do Brasil (oficial)
            try:
                response = requests.get(
                    "https://api.bcb.gov.br/dados/serie/bcdata.sgs.1/dados/ultimos/1?formato=json",
                    timeout=10
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data and len(data) > 0:
                        brl_rate = float(data[0].get('valor', 0))
                        if brl_rate > 0:
                            print(f"[BitgetAPI] Taxa USD/BRL obtida do Banco Central: {brl_rate:.4f}")
                            return brl_rate
            except Exception as e:
                print(f"[BitgetAPI] Erro na API do Banco Central: {e}")
            
            # M√©todo 3: Tentar Bitget (caso tenham algum par relacionado)
            try:
                # Verificar se existe BRLUSDT na Bitget
                response = requests.get(
                    f"{self.base_url}/api/v2/spot/market/tickers?symbol=BRLUSDT",
                    timeout=10
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('code') == '00000' and data.get('data'):
                        ticker_data = data['data'][0]
                        brl_usd_rate = float(ticker_data.get('lastPr', 0))
                        if brl_usd_rate > 0:
                            # Se for BRLUSDT, inverter para obter USDBRL
                            usd_brl_rate = 1 / brl_usd_rate
                            print(f"[BitgetAPI] Taxa USD/BRL calculada da Bitget BRLUSDT: {usd_brl_rate:.4f}")
                            return usd_brl_rate
            except Exception as e:
                print(f"[BitgetAPI] Erro ao verificar Bitget BRLUSDT: {e}")
            
            print("[BitgetAPI] Todas as APIs de cota√ß√£o falharam")
            return None
                
        except Exception as e:
            print(f"[BitgetAPI] Erro geral ao obter taxa USD/BRL: {e}")
            return None

    def get_market_price(self, symbol):
        """Obt√©m o pre√ßo de mercado atual para um s√≠mbolo espec√≠fico."""
        ticker_data = self.get_ticker(symbol)
        if ticker_data and 'data' in ticker_data and ticker_data['data']:
             # Para futuros, a lista pode conter mais de um item, mas geralmente o primeiro √© o correto
            if isinstance(ticker_data['data'], list) and len(ticker_data['data']) > 0:
                return float(ticker_data['data'][0].get('lastPr'))
            # Para spot, a estrutura pode ser diferente
            elif isinstance(ticker_data['data'], dict):
                 return float(ticker_data['data'].get('lastPr'))
        return None